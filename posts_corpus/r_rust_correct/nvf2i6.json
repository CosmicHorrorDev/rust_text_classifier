{
    "id": "nvf2i6",
    "title": "Newbie frustration: can we KISS more?",
    "selftext": "I understand that this could sound like a rant, but it really isn't. I want to share my experience as a Rust newbie and some of the pain-points I encountered in my journey.\n\n&#x200B;\n\n**The What**\n\nI want to build a small web server for a dashboard of a home automation project\n\n**The Why**\n\nI've been programming in Node.js with Express and TypeScript for years now and I feel very productive with these technologies, but I can see that the increased productivity on my part is proportional to a decrease in performance on my Raspberry, so I decided to go with Rust to be able to better handle parallelism, threading and memory allocation\n\n**The How**\n\nFirst I looked for a middleware-based web library/framework, like Express, and I found some crates, namely Tide, Thruster and Warp. I chose Warp because of <insert random heuristic/i liked the hello world example better than the others>.\n\n**Async madness**\n\nThen I found out about async/await and the fact that Rust does not ship with a useful runtime by default. I read about tokio, async-std, ...yada-yada.\n\nI mean... ok I guess? It's not too bad, everybody can choose what's best for their application and - nope, incompatibility issues!\n\nApparently there are crates that depend on tokio, crates that depend on async-std, crates that depend on different and incompatible versions of tokio! Wow, that escalated quickly!\n\nAt this point the only sensible choice for me was to go with the most popular -> tokio it is\n\nThis didn't feel right. I don't even understand why someone would write a library that only works on a specific runtime or just uses types of a specific runtime (I'm looking at you, reqwest...).\n\n**I just want a global config, please!**\n\nI kept going on, put a lot of effort into reading docs and after a couple of hours I got my web server up and running with some basic routes. Time to extract some hard-coded values and put them in environment variables.\n\nAnd so I did, I created a .env file, installed the dotenv crate, tested. It worked fine. Ok so, I don't want to get the environment variable from std::env every time as an Option, I want a global configuration object that stores all my settings as primitive types, like strings or integers, for example the ip and port the web server has to bind to.\n\nWhat I would do in JavaScript:\n\n`export const config = {http: {hostname: process.env.HOST || 'localhost',port: Number(process.env.PORT || '3000'),},// ...other stuff}`\n\nUnfortunately I found out that it's not possible to create a nested struct in Rust (am I wrong?), so I had to create a struct definition for every piece of configuration, like this:\n\n`struct HttpConfig {host: String,port: i32,}`\n\n`struct Config {http: HttpConfig,}`\n\nOk, it's a little more verbose, but still doable without any effort. Just a little bit annoying.\n\nBut then I realized that I couldn't simply build that static object, because `calls in statics are limited to constant functions, tuple structs and tuple variants`, and I needed to call env::var and other non-constant functions. So I found another crate, lazy\\_static, that completely solved my problem.\n\nBasically I had to resort to a third-party library, specifically a macro, because the language itself isn't enough to translate \"I want globally-accessible configurations (possibly readonly after initialization)\" into code.\n\n&#x200B;\n\nI'm sorry if this seems harsh, but I'm a bit frustrated. The amount of mental effort spent on studying all that documentation doesn't seem to have paid off, trivial things seem too hard and too much seems (IMO) to depend on macros and external crates. I'll definitely continue with this project, it's a personal one so I don't really have deadlines (apart from my attention span).\n\n&#x200B;\n\nHave you experienced similar problems? Did you find better solutions? Should we Keep It (more) Simple? Am I Stupid :( ?"
}