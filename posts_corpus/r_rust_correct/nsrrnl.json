{
    "id": "nsrrnl",
    "title": "Problem with shell i'm making",
    "selftext": "So, i'm trying to learn rust by writing a shell in it. After entering raw mode I had the issue where when I input a newline to type a command it still keeps it's x position, the solution was to simply replace '\\\\n' with '\\\\r\\\\n'. But now I have an issue where the newlines in the output of the command are still keeping X position. \n\n[Example running 'ls -l'](https://preview.redd.it/7gmgxs1iye371.png?width=1920&format=png&auto=webp&s=a8fae70bde1cb84818d86c95eaf9abc17f0421fb)\n\nIn the code im running the command with the .spawn() function, I have tried using .output() instead to put the output into a variable as a string then filitering and printing that. But then I can't launch TUI applications such as vim.\n\nSo I guess my question is how could I make newlines go back to the beginning in my command output while still keeping TUI app functionality?\n\n&#x200B;\n\nmain.rs -\n\n    extern crate termion;\n    use std::{fs, env};\n    use std::io::{stdin, stdout, Write};\n    use std::process::Command;\n    use termion::clear::CurrentLine;\n    use termion::event::Key;\n    use termion::input::TermRead;\n    use termion::raw::IntoRawMode;\n    use termion::color;\n    use termion::style;\n    \n    // OPTIONS\n    static prompt:&str = \"shell > \";\n    static error_msg:&str = \"??? wat\";\n    \n    static error_color:color::Red = color::Red;\n    \n    \n    fn main() {\n    \n        let stdin = stdin();\n    \n        // going into raw mode\n        let mut stdout = stdout().into_raw_mode().unwrap();\n    \n        // detecting keydown events\n        let mut command = String::new();\n        print!(\"\\r{} \", prompt);\n        stdout.flush().unwrap();\n        for c in stdin.keys() {\n            match c.unwrap() {\n    \n                Key::Ctrl('z') => break, // Exit on Ctrl-Z\n                Key::Char('\\t') => {\n                    print!(\"\\r\");\n                    command = autocomplete(&command); // function to run when Tab is pressed\n                    print!(\"{}\\r{} {}\", termion::clear::CurrentLine, prompt, command); // clear line\n                }\n                Key::Char('\\n') => { // When enter is pressed\n                    print!(\"\\n\"); // print new line\n                    run_command(&command);\n                    command = \"\".to_string(); // reset command\n                    print!(\"\\r{} \", prompt); // print new line\n                },\n                Key::Char(c) => { // when any regular character is pressed\n                    print!(\"{}\", c); // print character\n                    command.push(c); // append character to command\n                },\n                Key::Backspace => { // when backspace is pressed\n                    command.pop();\n                    print!(\"{}\\r{} {}\", termion::clear::CurrentLine, prompt, command); // clear line\n                },\n                _ => print!(\"{}\", command), // else print command\n            }\n    \n            stdout.flush().unwrap();\n        }\n    }\n    \n    fn run_command(command: &str) {\n        let mut parts = command.trim().split_whitespace(); // split command at each space\n        let command = parts.next().unwrap(); // set command to first word\n        let args = parts; // set args to everything in parts except first word\n    \n        match command {\n            \"cd\" => {\n                let new_dir = args.peekable().peek().map_or(\"/\", |x| x);\n                let root = std::path::Path::new(new_dir);\n                if let Err(e) = env::set_current_dir(&root) {\n                    eprintln!(\"{}{}{}\", color::Fg(error_color), error_msg, color::Fg(color::Reset));\n                }\n            }\n            command => {\n                let child = Command::new(command) // run the command and store it in child\n                    .args(args) // set args to well... args\n                    .spawn(); // run the command\n    \n                match child { // handling bad input\n                    Ok(mut child) => {child.wait(); },\n                    Err(e) => eprintln!(\"{}{}{}\", color::Fg(error_color), error_msg, color::Fg(color::Reset)), // error message\n                };\n            }\n        }\n    }\n    \n    fn autocomplete(command: &str) -> String {\n        let paths = fs::read_dir(\"./\").unwrap();\n    \n        let mut parts = command.trim().split_whitespace().peekable();\n        let mut without_last = String::new();\n        let mut last = String::new();\n    \n        while let Some(part) = parts.next() {\n            if parts.peek().is_some() {\n                // Not the last\n                without_last.push_str(part);\n            } else {\n                // last\n                last.push_str(part);\n            }\n        }\n    \n        let mut found = String::new();\n    \n        for path in paths {\n            let mut name: String = path.unwrap().path().display().to_string();\n            if name.contains(&last) {\n                found = without_last + \" \" + &name;\n                break\n            } else {\n                found = command.to_string();\n            }\n        }\n        found\n    }"
}