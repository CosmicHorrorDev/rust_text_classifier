{
    "id": "nvjiig",
    "title": "Why does the borrow checker accept a simple linked list traversal here but not a slightly more interesting one?",
    "selftext": "Here's a simple linked list `append` function. This compiles and runs just fine:\n\n    #[derive(Clone, Debug)]\n    struct Node {\n        val: String,\n        next: Option<Box<Node>>,\n    }\n\n    fn append(mut spot: &mut Option<Box<Node>>, val: String) {\n        // Find the tail of the list.\n        while let Some(node) = spot {\n            spot = &mut node.next;\n        }\n        // Append val at the tail.\n        *spot = Some(Box::new(Node { val, next: None }));\n    }\n\n    fn main() {\n        // Just a quick example of what append() is doing.\n        let mut list = None;\n        append(&mut list, \"foo\".into());\n        append(&mut list, \"bar\".into());\n        dbg!(list); // \"foo\" -> \"bar\" -> None\n    }\n\nHowever, if I make `append` just a little more interesting, this doesn't compile:\n\n    fn append_or_maybe_overwrite(mut spot: &mut Option<Box<Node>>, val: String) {\n        // Find the tail of the list, or maybe stop at an earlier node.\n        while let Some(node) = spot {\n            if rand::thread_rng().gen_range(0..10) == 0 {\n                break;\n            }\n            spot = &mut node.next;\n        }\n        // This fails to compile with:\n        // error[E0506]: cannot assign to `*spot` because it is borrowed\n        *spot = Some(Box::new(Node { val, next: None }));\n    }\n\nNotably, if I `panic!()` instead of `break` in that non-compiling example, it's fixed again. It seems like Rust is happy as long as the loop _always_ overwrites `spot` (or returns early), but not if the loop _maybe_ overwrites it (and allows execution to continue). Is this a specific case of some more general limitation? Is there a workaround that doesn't involve stashing a mutable reference in an `Option`?\n\n[playground link for all of this](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=fc1191d81c478ce863c8db382fe6591c)"
}